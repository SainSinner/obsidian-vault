###### Запуск внешних процессов - subprocess
```python
import subprocess
subprocess.call(["funcName", "funcParam"])
```
###### Requests/запрос
[Python Requests get() Method](https://www.w3schools.com/PYTHON/ref_requests_get.asp)  
[Python requests.Response Object](https://www.w3schools.com/PYTHON/ref_requests_response.asp)
###### Читаем контент файла в ответе и количество строк в нем
```python
url = 'https://stepik.org/media/attachments/course67/3.6.2/050.txt'
r = requests.get(url=url)
r = r.text.splitlines()
print(r)
print(len(r))
```
###### Генерация запроса по контенту файла(пример)
```python
import requests

fileFirst = '699991.txt'
r = "" 
fileName = "" 
while fileName.startswith("We") is False:
    if fileName == "":
        url = 'https://stepik.org/media/attachments/course67/3.6.3/' + fileFirst
        print("Log fileName: ", fileFirst, " ", url)
    else:
        url = 'https://stepik.org/media/attachments/course67/3.6.3/' + fileName
        print("Log fileName: ", fileName, " ", url)
    r = requests.get(url=url)
    r = r.text.splitlines()
    fileName = r[0]

print(requests.get(url=url).text)
```

###### Скачать файл по url
```shell
wget https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/samples/moviedata.zip
```

###### assert утверждение, когда нужно вывести сообщение в случае если равенство ошибочно, как здесь
```python
assert type('ice cream') == int, "If this fails, it will print this message"
# вернется следующая строка
# AssertionError: If this fails, it will print this message
```

A best practice is to create a "unit" test to verify our function.
An "AssertionError:" will only display if the function returns something that is not expected.
```python
assert "odd" == even_or_odd(101)
assert "even" == even_or_odd(400)
assert "odd" == even_or_odd(5)
assert "even" == even_or_odd(2)
assert "even" == even_or_odd(3780)
assert "odd" == even_or_odd(78963)
assert "UNKNOWN" == even_or_odd(1/3)
```
###### Type Hints  

Functions can be more strongly typed. Type hinting allows us to indicate the argument and return type.  
This is done by adding a colon space and data type to the parameter like below.  
`num: int`  
The return type is indicated with a hyphen, greater than and data type before the colon at the end of the signature line.  
`-> str:`
```python
def even_or_odd(num: int, error_string: str = "This isn't an even or odd number!") -> str:
    if num % 2 == 0:
        return "even"
    elif num % 2 == 1:
        return "odd"
    else:
        return error_string

# execute the function by passing it a number
even_or_odd(42)
```
###### import every function from numpy, you can use the wildcard **`*`**.
```python
from numpy import *

sqrt(12)
```
###### Updating Lists
```python
# Replace pancakes with waffles

breakfast_list[0] = "waffles"

print(f"After the update: {breakfast_list}")

  

# Append an item to the end of the list

breakfast_list.append("oatmeal")

print(f"After the append: {breakfast_list}")

  

# Remove the eggs to go vegan

del breakfast_list[2]

print(f"After the delete: {breakfast_list}")
```
###### Built-in Functions for Lists

Python has built-in functions for determining the length, minimum, and maximum of a collection.

 Code Text
 ```python
 item_count = len(breakfast_list)

print(f"You had {item_count} items for breakfast")

  

nums = [-7, 5, 1, 8, -3, 2]

print(f"The lowest value in the list is {min(nums)}")

print(f"The highest value in the list is {max(nums)}")
```
###### List Comprehensions
```python
caps_list = [item.capitalize() for item in breakfast_list]

print(f"Result of list comprehension: {caps_list}")
# Пример с использованием фильтра
square_positives = [i * i for i in nums if i > 0]

print(f"Square of positives list: {square_positives}")
```

###### Alternatively, you can use the dictionary **`get()`** method. This returns the value for the given key if present.
```python
# get() with a given default of 0

result1 = breakfast_dict.get("oatmeal", 0)

print(f"{result1}")

  

# get() with an implicit default of None

result2 = breakfast_dict.get("muesli")

print(f"{result2}")
```
###### Updating Dictionaries

Because a dictionary is a mutable collection, we can change its contents with operations like inserting, updating, and deleting elements.
```python
print(f"Original dictionary: {breakfast_dict}")

  

# Insert orange juice

breakfast_dict["orange juice"] = 110

print(f"After insert: {breakfast_dict}")

  

# Update the calorie count for waffles

breakfast_dict["waffles"] = 350

print(f"After update: {breakfast_dict}")

  

# Delete the pancakes

del breakfast_dict["pancakes"]

print(f"After delete: {breakfast_dict}")
```

###### Functions with Arbitrary Arguments
You can define a function in Python that accepts an arbitrary number of arguments with syntax like this:

`**def my_func(*args):       ...**`

The parameter name **`args`** is not required, but it is a common convention.

The **`args`** parameter is treated as a sequence containing all of the arguments passed to the function.
```python
def calculate_sum(*args):

    total = 0

    for value in args:

        total += value

    return total

  

print(f"sum(1, 2, 3, 4, 5) = {calculate_sum(1, 2, 3, 4, 5)}")

print(f"sum(1) = {calculate_sum(1)}")

print(f"sum() = {calculate_sum()}")
```

###### Functions with Arbitrary Keyword Arguments

A Python function can also accept arbitrary named arguments, which are referred to a _keyword arguments_, with syntax like this:

`**def my_func(**kwargs):       ...**`

The parameter name **`kwargs`** is not required, but it is a common convention.

The **`kwargs`** parameter is treated as a dictionary containing all of the argument names and values passed to the function.
```python
def my_func(**kwargs):

    print("Arguments received:")

    for key, value in kwargs.items():

        print(f"  {key}: {value}")

  

print("First Example\n=============")

my_func(first_name="James", last_name="Bond", drink="Martini - shaken, not stirred")

  

print("\nSecond Example\n==============")

my_func(movie_title="Casino Royale", release_year=2006)
```

###### Свойства класса и метод-конструктор

Свойства класса обычно определяются в специальном методе, называемом конструктором.

- Конструктор должен иметь имя `__init__()`.
    
- Python автоматически вызывает конструктор при создании экземпляра класса.
    
- Цель конструктора — инициализировать вновь созданный экземпляр, чаще всего путем установки начальных значений свойств объекта.
    

Вот пример более интересного класса, который включает конструктор, устанавливающий два свойства, и два дополнительных метода:
```python
class Person:

    # Defining the class constructor method

    def __init__(self, first_name, last_name):

        # Here we create the properties on self with the values provided in the constructor

        self.first_name = first_name

        self.last_name = last_name

  

    # Defining other class methods

    def greet(self, greeting="Hello!"):

        print(f"{self.first_name} says, '{greeting}'")

  

    def full_name(self):

        return self.first_name + " " + self.last_name

  

person1 = Person("Michelle", "Robinson")

person2 = Person(first_name="Barack", last_name="Obama")

  

person1.greet()

person2.greet("Hi!")

  

print(f"person1's current name: {person1.full_name()}")

person1.last_name = "Obama"  # You can change the value of object properties

print(f"person1's updated name: {person1.full_name()}")
```
###### yield
 **Что делает `yield`**

- Когда функция встречает `yield`, она **возвращает значение** вызывающему коду, **но при этом сохраняет своё состояние**.
    
- При следующем вызове генератора выполнение функции продолжается **с места, где она остановилась**, а не с начала.
 **Аналогия**

- `return` = я возвращаю результат и забываю всё, что было.
    
- `yield` = я возвращаю результат **и ставлю “закладку”**, чтобы продолжить с этого места позже.